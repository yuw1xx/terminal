<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal - Linux Kernel 5.15</title>
    <style>
        :root {
            --bg-color: #0c0c0c;
            --fg-color: #cccccc;
            --prompt-user: #11a143;
            --prompt-path: #3b78ff;
            --dir-color: #3b78ff;
            --file-color: #cccccc;
            --exec-color: #11a143;
            --error-color: #e74856;
            --font-family: 'Cascadia Code', 'Ubuntu Mono', 'Courier New', monospace;
            --font-size: 15px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body, html {
            height: 100%; width: 100%;
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: var(--font-family);
            font-size: var(--font-size);
            overflow: hidden;
            position: relative;
        }

        #terminal {
            height: 100%; width: 100%;
            padding: 15px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #444 transparent;
            display: flex;
            flex-direction: column;
        }

        #terminal::-webkit-scrollbar { width: 6px; }
        #terminal::-webkit-scrollbar-thumb { background-color: #444; border-radius: 3px; }

        .output-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .input-line {
            display: none; /* Hidden during boot */
            align-items: center;
            margin-top: 5px;
            flex-wrap: wrap;
        }

        .prompt { font-weight: bold; margin-right: 8px; white-space: pre; }
        .prompt .user { color: var(--prompt-user); }
        .prompt .path { color: var(--prompt-path); }

        #cmd-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            min-width: 50%;
        }

        .dir { color: var(--dir-color); font-weight: bold; }
        .exec { color: var(--exec-color); font-weight: bold; }
        .error { color: var(--error-color); }
        .boot-log { color: #aaa; font-size: 13px; }
        .success { color: #11a143; }

        /* Full-screen UI components */
        #top-overlay, #nano-editor, #cmatrix-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            z-index: 100;
        }

        #top-overlay { padding: 10px; flex-direction: column; }
        #cmatrix-overlay { z-index: 200; background-color: black; }

        /* Nano Specifics */
        #nano-editor { flex-direction: column; }
        #nano-header {
            background-color: #ddd; color: #000;
            padding: 2px 10px; font-weight: bold; display: flex; justify-content: space-between;
        }
        #nano-footer {
            background-color: #ddd; color: #000;
            padding: 5px 10px; font-weight: bold; display: flex; gap: 20px; flex-wrap: wrap;
        }
        #nano-textarea {
            flex-grow: 1; background: transparent; color: inherit;
            border: none; padding: 10px; font-family: inherit; font-size: inherit;
            outline: none; resize: none;
        }

        /* Nano Command prompt overlay */
        #nano-prompt {
            display: none; background-color: var(--bg-color); color: var(--fg-color);
            padding: 5px 10px; border-top: 1px solid #444; align-items: center;
        }
        #nano-prompt-text { margin-right: 10px; }
        #nano-prompt-input { background: transparent; border: none; color: inherit; outline: none; font-family: inherit; flex-grow: 1;}

        .ls-l-table { display: table; margin: 5px 0; }
        .ls-l-row { display: table-row; }
        .ls-l-cell { display: table-cell; padding-right: 15px; white-space: pre; }
    </style>
</head>
<body>

    <div id="terminal">
        <div id="output"></div>
        <div class="input-line" id="input-container">
            <span class="prompt" id="prompt"></span>
            <input type="text" id="cmd-input" autocomplete="off" spellcheck="false" autofocus>
        </div>
    </div>

    <!-- Nano Editor -->
    <div id="nano-editor">
        <div id="nano-header">
            <span>GNU nano 5.4</span>
            <span id="nano-filename">New Buffer</span>
            <span></span>
        </div>
        <textarea id="nano-textarea" spellcheck="false"></textarea>
        <div id="nano-prompt">
            <span id="nano-prompt-text"></span>
            <input type="text" id="nano-prompt-input" autocomplete="off" spellcheck="false">
        </div>
        <div id="nano-footer">
            <span>^G Get Help</span> <span>^O Write Out</span> <span>^W Where Is</span> <span>^K Cut Text</span>
            <span>^X Exit</span> <span>^R Read File</span> <span>^\\ Replace</span> <span>^U Uncut Text</span>
        </div>
    </div>

    <!-- Top Overlay -->
    <div id="top-overlay">
        <div id="top-content" style="white-space: pre; font-family: monospace;"></div>
    </div>

    <!-- CMatrix Overlay -->
    <canvas id="cmatrix-overlay"></canvas>

    <script>
        // --- System Internals ---
        const startTime = Date.now();
        let env = { USER: 'guest', HOME: '/home/guest', PWD: '/home/guest', SHELL: '/bin/bash', PATH: '/bin:/usr/bin' };
        let currentPath = ['home', 'guest'];
        let cmdHistory = [];
        let historyIndex = -1;
        let processes = [
            { pid: 1, name: 'systemd', user: 'root', cpu: 0.1, mem: 1.2 },
            { pid: 42, name: 'bash', user: 'guest', cpu: 0.0, mem: 0.5 },
            { pid: 502, name: 'sshd', user: 'root', cpu: 0.0, mem: 0.2 }
        ];

        // --- Virtual File System ---
        function createNode(type, content = '', owner = 'root', perms = null) {
            return {
                type, content, owner,
                group: owner === 'root' ? 'root' : 'users',
                perms: perms || (type === 'dir' ? 'drwxr-xr-x' : (type === 'exec' ? '-rwxr-xr-x' : '-rw-r--r--')),
                date: new Date().toLocaleString('en-US', { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }).replace(',', ''),
                size: type === 'dir' ? 4096 : content.length
            };
        }

        const vfs = createNode('dir', {
            'bin': createNode('dir', {
                'bash': createNode('exec', 'ELF...', 'root'),
                'ls': createNode('exec', 'ELF...', 'root')
            }),
            'etc': createNode('dir', {
                'hostname': createNode('file', 'webos-server\n'),
                'passwd': createNode('file', 'root:x:0:0:root:/root:/bin/bash\nguest:x:1000:1000:guest:/home/guest:/bin/bash\n'),
                'motd': createNode('file', 'Welcome to WebOS Linux 5.15 LTS\n* Documentation: https://github.com/webos\n')
            }),
            'home': createNode('dir', {
                'guest': createNode('dir', {
                    'documents': createNode('dir', {
                        'notes.txt': createNode('file', 'Remember to fix the JS VFS logic tomorrow.', 'guest')
                    }, 'guest'),
                    'script.py': createNode('file', 'print("Hello from Python simulation")', 'guest')
                }, 'guest')
            }),
            'proc': createNode('dir', {}), // Dynamic
            'var': createNode('dir', { 'log': createNode('dir', { 'syslog': createNode('file', 'Initial boot complete.\n') }) })
        });

        // --- UI Logic ---
        const outputEl = document.getElementById('output');
        const inputEl = document.getElementById('cmd-input');
        const promptEl = document.getElementById('prompt');
        const inputContainer = document.getElementById('input-container');
        const terminal = document.getElementById('terminal');

        function print(text, className = '') {
            const div = document.createElement('div');
            div.className = 'output-line ' + className;
            div.innerHTML = text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            outputEl.appendChild(div);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function printHTML(html, className = '') {
            const div = document.createElement('div');
            div.className = 'output-line ' + className;
            div.innerHTML = html;
            outputEl.appendChild(div);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function updatePrompt() {
            const pathStr = '/' + currentPath.join('/');
            const displayPath = pathStr.startsWith(env.HOME) ? '~' + pathStr.slice(env.HOME.length) : (pathStr || '/');
            promptEl.innerHTML = `<span class="user">${env.USER}@webos</span>:<span class="path">${displayPath}</span>${env.USER === 'root' ? '#' : '$'}`;
        }

        // --- Path Resolution ---
        function resolvePath(pathStr) {
            if (!pathStr) return [...currentPath];
            if (pathStr === '~') return env.HOME.split('/').filter(x => x);
            let parts = pathStr.split('/').filter(p => p !== '');
            let target = pathStr.startsWith('/') ? [] : [...currentPath];

            for (let p of parts) {
                if (p === '.') continue;
                if (p === '..') { if (target.length > 0) target.pop(); }
                else target.push(p);
            }
            return target;
        }

        function getNode(pathArr) {
            let curr = vfs;
            for (let p of pathArr) {
                if (!curr || curr.type !== 'dir' || !curr.content[p]) return null;
                curr = curr.content[p];
            }
            return curr;
        }

        function getParentNodeAndName(pathArr) {
            if (pathArr.length === 0) return { parent: null, name: '' };
            let parentPath = pathArr.slice(0, -1);
            let name = pathArr[pathArr.length - 1];
            return { parent: getNode(parentPath), name: name };
        }

        // --- Command System ---
        const commands = {
            help: () => {
                return `GNU bash, version 5.1.16(1)-release (x86_64-webos-linux-gnu)
Available commands:
  help      cd        ls        pwd       cat       echo
  mkdir     touch     rm        nano      ps        top
  su        whoami    date      uptime    ping      curl
  clear     history   neofetch  apt       cmatrix

Pro-tips:
- Use Up/Down arrows for command history.
- Use Tab to auto-complete commands and file names.
- Try running 'cmatrix' for a cool effect!`;
            },
            clear: () => { outputEl.innerHTML = ''; return null; },
            pwd: () => '/' + currentPath.join('/'),
            whoami: () => env.USER,
            date: () => new Date().toString(),
            history: () => cmdHistory.map((c, i) => `  ${i+1}  ${c}`).join('\n'),
            uptime: () => {
                const diff = Math.floor((Date.now() - startTime) / 1000);
                return `up ${Math.floor(diff / 60)} minutes, 1 user, load average: 0.01, 0.05, 0.10`;
            },
            ls: (args) => {
                const long = args.includes('-l');
                const all = args.includes('-a');
                const target = resolvePath(args.find(a => !a.startsWith('-')) || '');
                const node = getNode(target);
                if (!node || node.type !== 'dir') return `<span class="error">ls: cannot access: No such directory</span>`;
                
                let keys = Object.keys(node.content);
                if (all) keys = ['.', '..', ...keys];
                keys.sort();

                if (long) {
                    let html = '<div class="ls-l-table">';
                    html += `<div class="ls-l-row"><span class="ls-l-cell">total ${keys.length * 4}</span></div>`;
                    keys.forEach(k => {
                        const item = (k === '.' || k === '..') ? node : node.content[k];
                        const cName = item.type === 'dir' ? 'dir' : (item.type === 'exec' ? 'exec' : 'file');
                        html += `<div class="ls-l-row">
                            <span class="ls-l-cell">${item.perms}</span>
                            <span class="ls-l-cell">${item.owner}</span>
                            <span class="ls-l-cell">${item.group}</span>
                            <span class="ls-l-cell" style="text-align:right">${item.size}</span>
                            <span class="ls-l-cell">${item.date}</span>
                            <span class="ls-l-cell ${cName}">${k}</span>
                        </div>`;
                    });
                    return html + '</div>';
                }
                return keys.map(k => {
                    const item = (k === '.' || k === '..') ? node : node.content[k];
                    const cName = item.type === 'dir' ? 'dir' : (item.type === 'exec' ? 'exec' : 'file');
                    return `<span class="${cName}">${k}</span>`;
                }).join('  ');
            },
            cd: (args) => {
                const target = resolvePath(args[0] || '~');
                const node = getNode(target);
                if (node && node.type === 'dir') { currentPath = target; updatePrompt(); return null; }
                return `<span class="error">cd: ${args[0]}: No such directory</span>`;
            },
            cat: (args) => {
                if (!args[0]) return `<span class="error">cat: missing file operand</span>`;
                const node = getNode(resolvePath(args[0]));
                if (!node) return `<span class="error">cat: ${args[0]}: No such file</span>`;
                if (node.type === 'dir') return `<span class="error">cat: ${args[0]}: Is a directory</span>`;
                return node.content;
            },
            echo: (args) => args.join(' '),
            mkdir: (args) => {
                if (!args[0]) return `<span class="error">mkdir: missing operand</span>`;
                const { parent, name } = getParentNodeAndName(resolvePath(args[0]));
                if (!parent || parent.type !== 'dir') return `<span class="error">mkdir: cannot create directory '${args[0]}'</span>`;
                if (parent.content[name]) return `<span class="error">mkdir: cannot create directory '${args[0]}': File exists</span>`;
                parent.content[name] = createNode('dir', {}, env.USER);
                return null;
            },
            touch: (args) => {
                if (!args[0]) return `<span class="error">touch: missing operand</span>`;
                const { parent, name } = getParentNodeAndName(resolvePath(args[0]));
                if (!parent || parent.type !== 'dir') return `<span class="error">touch: cannot touch '${args[0]}'</span>`;
                if (!parent.content[name]) parent.content[name] = createNode('file', '', env.USER);
                else parent.content[name].date = new Date().toLocaleString('en-US', { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }).replace(',', '');
                return null;
            },
            rm: (args) => {
                if (!args[0]) return `<span class="error">rm: missing operand</span>`;
                const { parent, name } = getParentNodeAndName(resolvePath(args[0]));
                if (!parent || !parent.content[name]) return `<span class="error">rm: cannot remove '${args[0]}': No such file</span>`;
                if (parent.content[name].type === 'dir' && !args.includes('-r')) return `<span class="error">rm: cannot remove '${args[0]}': Is a directory</span>`;
                delete parent.content[name];
                return null;
            },
            su: (args) => {
                const user = args[0] || 'root';
                print(`Password for ${user}: `); 
                setTimeout(() => {
                    env.USER = user;
                    env.HOME = user === 'root' ? '/root' : '/home/' + user;
                    currentPath = env.HOME.split('/').filter(x => x);
                    updatePrompt();
                    print(`Logged in as ${user}`, 'success');
                }, 800);
                return null;
            },
            ps: () => {
                let out = "  PID TTY          TIME CMD\n";
                processes.forEach(p => out += `${p.pid.toString().padStart(5)} pts/0    00:00:00 ${p.name}\n`);
                return out;
            },
            top: () => {
                const overlay = document.getElementById('top-overlay');
                const content = document.getElementById('top-content');
                overlay.style.display = 'flex';
                inputEl.blur();
                const interval = setInterval(() => {
                    let out = `top - ${new Date().toLocaleTimeString()} up ...\n`;
                    out += `Tasks: ${processes.length} total, 1 running, ${processes.length - 1} sleeping\n`;
                    out += `%Cpu(s): ${ (Math.random() * 2).toFixed(1) } us, 1.2 sy, 0.0 ni, 98.5 id\n\n`;
                    out += `  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\n`;
                    processes.forEach(p => {
                        out += `${p.pid.toString().padStart(5)} ${p.user.padEnd(8)} 20   0  162312  24212   1241 S   ${p.cpu.toFixed(1)}   ${p.mem.toFixed(1)}   0:00.01 ${p.name}\n`;
                    });
                    content.innerText = out;
                }, 1000);

                const endTop = (e) => {
                    if (e.key === 'q' || e.key === 'Escape') {
                        clearInterval(interval);
                        overlay.style.display = 'none';
                        window.removeEventListener('keydown', endTop);
                        setTimeout(() => inputEl.focus(), 10);
                    }
                };
                window.addEventListener('keydown', endTop);
                return null;
            },
            ping: (args) => {
                if (!args[0]) return "Usage: ping <host>";
                let count = 0;
                print(`PING ${args[0]} (1.1.1.1) 56(84) bytes of data.`);
                const int = setInterval(() => {
                    print(`64 bytes from 1.1.1.1: icmp_seq=${++count} ttl=58 time=${(Math.random()*20+10).toFixed(1)} ms`);
                    if (count >= 4) {
                        clearInterval(int);
                        print(`--- ${args[0]} ping statistics ---`);
                        print(`4 packets transmitted, 4 received, 0% packet loss`);
                    }
                }, 1000);
                return null;
            },
            curl: (args) => {
                if (!args[0]) return "curl: try 'curl --help' for more information";
                print(`Connecting to ${args[0]}...`);
                setTimeout(() => print(`HTTP/1.1 200 OK\nContent-Type: text/html\n\n&lt;html&gt;&lt;body&gt;Welcome to ${args[0]}&lt;/body&gt;&lt;/html&gt;`), 1200);
                return null;
            },
            neofetch: () => {
                const logo = `<span style="color: var(--prompt-path);">       _,met$$$$$gg.</span>
<span style="color: var(--prompt-path);">    ,g$$$$$$$$$$$$$$$P.</span>
<span style="color: var(--prompt-path);">  ,g$$P"     """Y$$.".</span>
<span style="color: var(--prompt-path);"> ,$$P'              \`$$$.</span>
<span style="color: var(--prompt-path);">',$$P       ,ggs.     \`$$b:</span>
<span style="color: var(--prompt-path);">\`d$$'     ,$P"'   <span style="color: var(--error-color);">.</span>    $$$</span>
<span style="color: var(--prompt-path);"> $$P      d$'     <span style="color: var(--error-color);">,</span>    $$P</span>
<span style="color: var(--prompt-path);"> $$:      $$.   <span style="color: var(--error-color);">-</span>    ,d$$'</span>
<span style="color: var(--prompt-path);"> $$;      Y$b._   _,d$P'</span>
<span style="color: var(--prompt-path);"> Y$$.    <span style="color: var(--error-color);">\`</span>.\`"Y$$$$P"'</span>
<span style="color: var(--prompt-path);"> \`$$b      <span style="color: var(--error-color);">"-.__</span></span>
<span style="color: var(--prompt-path);">  \`Y$$</span>
<span style="color: var(--prompt-path);">   \`Y$$.</span>`;
                const info = `<span style="color: var(--prompt-user); font-weight: bold;">${env.USER}@webos</span>
-------------------
<span style="color: var(--prompt-path); font-weight: bold;">OS</span>: WebOS GNU/Linux
<span style="color: var(--prompt-path); font-weight: bold;">Host</span>: Browser
<span style="color: var(--prompt-path); font-weight: bold;">Kernel</span>: 5.15.0-webos
<span style="color: var(--prompt-path); font-weight: bold;">Uptime</span>: ${Math.floor((Date.now() - startTime) / 60000)} mins
<span style="color: var(--prompt-path); font-weight: bold;">Packages</span>: 42 (dpkg)
<span style="color: var(--prompt-path); font-weight: bold;">Shell</span>: bash 5.1.16
<span style="color: var(--prompt-path); font-weight: bold;">DE</span>: Web DOM
<span style="color: var(--prompt-path); font-weight: bold;">Terminal</span>: HTML/JS Term
<span style="color: var(--prompt-path); font-weight: bold;">CPU</span>: Virtual Web Core
<span style="color: var(--prompt-path); font-weight: bold;">Memory</span>: 241MiB / 4096MiB`;
                return `<div style="display: flex; gap: 30px; margin: 10px 0;"><div>${logo.split('\n').join('<br>')}</div><div>${info.split('\n').join('<br>')}</div></div>`;
            },
            apt: (args) => {
                if (args[0] === 'install') {
                    if (!args[1]) return `<span class="error">apt: missing package name</span>`;
                    return `Reading package lists... Done\nBuilding dependency tree... Done\nReading state information... Done\nThe following NEW packages will be installed:\n  ${args[1]}\n0 upgraded, 1 newly installed, 0 to remove.\n<span class="success">[OK]</span> Installed ${args[1]} successfully.`;
                }
                return `Usage: apt install [package]`;
            },
            nano: (args) => {
                const filename = args[0] || 'new_file.txt';
                const { parent, name } = getParentNodeAndName(resolvePath(filename));
                
                if (!parent || parent.type !== 'dir') return `<span class="error">nano: cannot open directory</span>`;
                
                let fileNode = parent.content[name];
                if (fileNode && fileNode.type === 'dir') return `<span class="error">nano: ${filename} is a directory</span>`;

                const editor = document.getElementById('nano-editor');
                const textarea = document.getElementById('nano-textarea');
                const fnameEl = document.getElementById('nano-filename');
                const prmpt = document.getElementById('nano-prompt');
                const prmptInput = document.getElementById('nano-prompt-input');
                const footer = document.getElementById('nano-footer');

                editor.style.display = 'flex';
                fnameEl.innerText = filename;
                textarea.value = fileNode ? fileNode.content : '';
                textarea.focus();

                let isSaving = false;

                const nanoKeyHandler = (e) => {
                    if (e.ctrlKey && e.key === 'x') {
                        e.preventDefault();
                        if (textarea.value !== (fileNode ? fileNode.content : '')) {
                            // Modified
                            footer.style.display = 'none';
                            prmpt.style.display = 'flex';
                            document.getElementById('nano-prompt-text').innerText = "Save modified buffer? (Y/N)";
                            prmptInput.focus();
                            isSaving = true;
                        } else {
                            exitNano();
                        }
                    }
                };

                const promptKeyHandler = (e) => {
                    if (!isSaving) return;
                    if (e.key.toLowerCase() === 'y') {
                        // Save and exit
                        if (!fileNode) parent.content[name] = createNode('file', textarea.value, env.USER);
                        else parent.content[name].content = textarea.value;
                        exitNano();
                    } else if (e.key.toLowerCase() === 'n') {
                        exitNano(); // Exit without saving
                    } else if (e.key === 'Escape' || (e.ctrlKey && e.key === 'c')) {
                        // Cancel
                        isSaving = false;
                        prmpt.style.display = 'none';
                        footer.style.display = 'flex';
                        textarea.focus();
                    }
                };

                const exitNano = () => {
                    editor.style.display = 'none';
                    prmpt.style.display = 'none';
                    footer.style.display = 'flex';
                    textarea.removeEventListener('keydown', nanoKeyHandler);
                    prmptInput.removeEventListener('keydown', promptKeyHandler);
                    inputEl.focus();
                };

                textarea.addEventListener('keydown', nanoKeyHandler);
                prmptInput.addEventListener('keydown', promptKeyHandler);
                return null;
            },
            cmatrix: () => {
                const canvas = document.getElementById('cmatrix-overlay');
                const ctx = canvas.getContext('2d');
                canvas.style.display = 'block';
                inputEl.blur();

                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=<>?'.split('');
                const fontSize = 16;
                const columns = canvas.width / fontSize;
                const drops = [];
                for (let x = 0; x < columns; x++) drops[x] = 1;

                const draw = () => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#0F0';
                    ctx.font = fontSize + 'px monospace';

                    for (let i = 0; i < drops.length; i++) {
                        const text = chars[Math.floor(Math.random() * chars.length)];
                        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
                        drops[i]++;
                    }
                };

                const interval = setInterval(draw, 33);

                const endMatrix = (e) => {
                    if (e.key === 'q' || e.key === 'Escape' || (e.ctrlKey && e.key === 'c')) {
                        clearInterval(interval);
                        canvas.style.display = 'none';
                        window.removeEventListener('keydown', endMatrix);
                        setTimeout(() => inputEl.focus(), 10);
                    }
                };
                window.addEventListener('keydown', endMatrix);
                return null;
            }
        };

        // --- Kernel Boot ---
        const bootMessages = [
            "[    0.000000] Linux version 5.15.0-webos (webos@builder) (gcc version 11.2.0)",
            "[    0.004210] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'",
            "[    0.124501] audit: initializing netlink subsys (disabled)",
            "[    0.654123] Freeing unused kernel image (m) memory: 2048K",
            "[    1.002341] Run /sbin/init as init process",
            "[    1.564321] systemd[1]: Reached target Local File Systems.",
            "[    2.543210] systemd[1]: Reached target Multi-User System."
        ];

        async function boot() {
            for (const msg of bootMessages) {
                print(msg, 'boot-log');
                await new Promise(r => setTimeout(r, Math.random() * 100 + 30));
            }
            print("\nWebOS Linux 5.15.0-webos tty1\n", "success");
            print("Type 'help' for a list of commands.\nTry 'cmatrix' for a cool effect!\n");
            inputContainer.style.display = 'flex';
            updatePrompt();
            inputEl.focus();
        }

        // --- Execution Logic ---
        inputEl.addEventListener('keydown', (e) => {
            // Command History Navigation
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (cmdHistory.length > 0 && historyIndex < cmdHistory.length - 1) {
                    historyIndex++;
                    inputEl.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                }
                return;
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    inputEl.value = cmdHistory[cmdHistory.length - 1 - historyIndex];
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    inputEl.value = '';
                }
                return;
            }

            // Tab Autocomplete
            if (e.key === 'Tab') {
                e.preventDefault();
                const raw = inputEl.value;
                const args = raw.split(' ');
                const lastToken = args.pop();
                
                // If first word, complete command
                if (args.length === 0) {
                    const matches = Object.keys(commands).filter(c => c.startsWith(lastToken));
                    if (matches.length === 1) inputEl.value = matches[0] + ' ';
                } else {
                    // Complete file/folder in current dir
                    const node = getNode(currentPath);
                    if (node && node.type === 'dir') {
                        const matches = Object.keys(node.content).filter(f => f.startsWith(lastToken));
                        if (matches.length === 1) {
                            const isDir = node.content[matches[0]].type === 'dir';
                            inputEl.value = args.join(' ') + ' ' + matches[0] + (isDir ? '/' : '');
                        }
                    }
                }
                return;
            }

            // Execute Command
            if (e.key === 'Enter') {
                const raw = inputEl.value;
                inputEl.value = '';
                
                if (raw.trim() !== '') {
                    cmdHistory.push(raw);
                    historyIndex = -1;
                }

                const args = raw.trim().split(/\s+/);
                const cmd = args.shift();

                printHTML(`${promptEl.innerHTML} ${raw}`);

                if (!cmd) return;
                
                // Redirection check (e.g. echo "hello" > file.txt)
                let redirectIdx = args.indexOf('>');
                let redirectFile = null;
                if (redirectIdx !== -1) {
                    redirectFile = args.splice(redirectIdx)[1];
                }

                if (commands[cmd]) {
                    const result = commands[cmd](args);
                    if (result !== null && result !== undefined) {
                        if (redirectFile) {
                            const { parent, name } = getParentNodeAndName(resolvePath(redirectFile));
                            if (parent && parent.type === 'dir') {
                                // Strip HTML tags before writing to VFS
                                const cleanResult = result.replace(/<[^>]*>?/gm, '');
                                if (!parent.content[name]) parent.content[name] = createNode('file', cleanResult, env.USER);
                                else parent.content[name].content = cleanResult;
                            } else {
                                print(`<span class="error">bash: ${redirectFile}: No such directory</span>`);
                            }
                        } else {
                            if (result.includes('<span') || result.includes('<div')) printHTML(result);
                            else print(result);
                        }
                    }
                } else {
                    print(`${cmd}: command not found`, 'error');
                }
            }
            
            // Handle Ctrl+C
            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                printHTML(`${promptEl.innerHTML} ${inputEl.value}^C`);
                inputEl.value = '';
                historyIndex = -1;
            }
            
            // Handle Ctrl+L
            if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                commands.clear();
            }
        });

        // Ensure focus is kept on terminal click
        terminal.addEventListener('click', () => {
            if (document.getElementById('nano-editor').style.display !== 'flex' && 
                document.getElementById('top-overlay').style.display !== 'flex' &&
                document.getElementById('cmatrix-overlay').style.display !== 'block') {
                inputEl.focus();
            }
        });

        window.onload = boot;
    </script>
</body>
</html>
